<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Projects | Dhanasankar K</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <!-- Navigation -->
  <nav>
    <ul>
      <li><a href="index.html">Home</a></li>
      <li><a href="about.html">About</a></li>
      <li><a href="projects.html" class="active">Projects</a></li>
      <li><a href="academic_projects.html">Academic Projects</a></li>
      <li><a href="contact.html">Contact</a></li>
    </ul>
  </nav>

  <!-- Main Content -->
  <main
    <div class="tech-contact-wrapper">
    <h2>My Projects</h2>

    <!-- Filter Buttons -->
    <div class="filter-buttons">
      <button onclick="filterProjects('all')">All</button>
      <button onclick="filterProjects('fpga')">FPGA</button>
      <button onclick="filterProjects('verilog')">Verilog</button>
    </div>

    <!-- Projects List -->
    <div class="projects">
      <div class="project-card" data-type="fpga" data-title="Real-Time FPGA Image Processing with 46 Filters" data-content='
  <strong>ğŸš€ Project Overview</strong><br><br>

  I am proud to share my advanced project titled <strong>â€œHigh-Performance FPGA-Based Real-Time Image Processing for Sobel Edge Detection and Noise Reductionâ€</strong>, implemented using the <span class="highlight-line">Edge Artix-7 FPGA Board</span> and developed with the <span class="highlight-line">Xilinx Vivado Design Suite</span>.<br><br>

  This project brings real-time image processing capabilities into hardware using <strong>Verilog HDL</strong>, enabling high-speed edge detection and dynamic noise reduction with <strong>46 unique pixel-level filters</strong>. It showcases the power of FPGAs in embedded computer vision and edge computing applications.<br><br>

  <strong>âš™ï¸ System Architecture & Workflow</strong><br>
  <u><strong>Image Input:</strong></u><br>
  â€¢ Grayscale image captured using an OV5640 camera module<br>
  â€¢ Each 8-bit pixel is streamed into the FPGA for processing<br><br>

  <u><strong>Filter Engine:</strong></u><br>
  â€¢ 46 unique filters built using Verilog<br>
  â€¢ Controlled via <code>SW[5:0]</code> (6-bit filter selector)<br>
  â€¢ Supports both basic and complex filters including Sobel, blur, threshold, etc.<br><br>

  <u><strong>Sobel Edge Detection Core:</strong></u><br>
  â€¢ 3Ã—3 sliding window convolution logic for horizontal and vertical edges<br><br>

  <u><strong>Noise Reduction & Enhancement:</strong></u><br>
  â€¢ Gaussian, box, and motion blur<br>
  â€¢ Morphological erosion/dilation<br><br>

  <u><strong>Output:</strong></u><br>
  â€¢ Real-time VGA display output<br>
  â€¢ Switch between filters instantly using on-board switches<br><br>

  <strong>ğŸ§  6-Bit Switch-Controlled Filter Selection</strong><br>
  â€¢ <code>SW[5:0]</code> defines the active filter<br>
  â€¢ Examples:<br>
    â€¢ <code>000000</code> â†’ Threshold<br>
    â€¢ <code>000001</code> â†’ Brighten<br>
    â€¢ <code>000100</code> â†’ Sobel + Erosion<br>
    â€¢ <code>001010</code> â†’ Laplacian Edge Detection<br>
    â€¢ ... up to <code>101101</code> â†’ Histogram Equalization (total 46 filters)<br><br>

  <strong>ğŸ” All 46 Verilog Filters Implemented:</strong><br><br>

  ğŸ”¹ <u>Basic Pixel Operations:</u><br>
  Brighten, Darken, Invert, Threshold, Half Brightness, Double Brightness, Safe Double Brightness<br><br>

  ğŸ”¹ <u>Frequency Filters:</u><br>
  High-Pass, Low-Pass, Band-Pass<br><br>

  ğŸ”¹ <u>Contrast & Histogram:</u><br>
  Contrast Enhance, Contrast Reduce, Histogram Equalization (approx), Contrast Stretching<br><br>

  ğŸ”¹ <u>Bitwise & Logical Filters:</u><br>
  Bitwise Invert, Mask Upper/Lower 4 Bits, XOR Pattern (0xAA/0x55), Narrow Band Shift<br><br>

  ğŸ”¹ <u>Thresholding & Binarization:</u><br>
  Mid Binarize, Smart Threshold, Inverted Binarize, LSB Binarize, Binary Edge Map, Threshold + Dilation<br><br>

  ğŸ”¹ <u>Add/Subtract Operations:</u><br>
  Manual Add, Manual Subtract, Offset + Shrink<br><br>

  ğŸ”¹ <u>Smoothing & Blur:</u><br>
  Gaussian Blur, Box Blur, Motion Blur, Median Filter (placeholder)<br><br>

  ğŸ”¹ <u>Edge Detection & Enhancements:</u><br>
  Sobel, Sobel + Erosion, Laplacian, Emboss, Sharpen, Gradient Magnitude, Gx, Gy<br><br>

  ğŸ”¹ <u>Morphological Filters:</u><br>
  Erosion, Dilation<br><br>

  ğŸ”¹ <u>Custom Kernels:</u><br>
  XOR-based Custom Kernel 1, Kernel 2, Noise-Isolated Map<br><br>

  <strong>ğŸ§ª Simulation and Implementation</strong><br>
  â€¢ RTL Simulation: <strong>Icarus Verilog</strong><br>
  â€¢ Waveform: <strong>GTKWave</strong><br>
  â€¢ Synthesis: <strong>Vivado 2023</strong><br>
  â€¢ Real-time Display: <strong>VGA Monitor</strong><br>
  â€¢ Filter Switching: <strong>FSM + MUX Logic</strong><br><br>

  <strong>ğŸ’¡ Highlights:</strong><br>
  âœ… Multi-stage filter pipeline<br>
  âœ… Switch-controlled real-time filter switching<br>
  âœ… Fully synthesizable Verilog RTL<br>
  âœ… Camera-to-VGA live video processing<br><br>

  <strong>ğŸ“¸ Live Output Flow:</strong><br>
  OV5640 Camera â†’ FPGA â†’ Filter Engine â†’ VGA Monitor<br><br>

  <strong>ğŸ™ Acknowledgements:</strong><br>
  Special thanks to <strong>Dr. Swami, Ph.D, iFellow</strong> (Silicon Craft VLSI) and <strong>Silicic Innova Technologies Pvt Ltd</strong> for their support and mentorship.<br><br>

  <strong>ğŸ”— GitHub:</strong><br>
  <a href="https://github.com/DHANASANKAR2003" target="_blank">
    <i class="fab fa-github"></i> GitHub
  </a><br><br>

  <strong>ğŸ–¼ï¸ Project Snapshots:</strong><br>

  <img src="images/fpga_project1.jpeg" alt="FPGA Project Setup" style="max-width:100%; border-radius:8px; margin:10px 0;"><br>
  <em style="color:#aaa">Figure 1: Artix-7 Board and Camera Setup</em><br><br>

  <img src="images/fpga_project2.jpeg" alt="Filter Block Diagram" style="max-width:100%; border-radius:8px; margin:10px 0;"><br>
  <em style="color:#aaa">Figure 2: Verilog Block Diagram for Filter Engine</em><br><br>

  <img src="images/fpga_project3.jpeg" alt="Verilog Filter Code Screenshot" style="max-width:100%; border-radius:8px; margin:10px 0;"><br>
  <em style="color:#aaa">Figure 3: Sample Verilog Case Structure for Filter Selection</em><br><br>

  <img src="images/fpga_project4.jpeg" alt="Vivado Implementation Screenshot" style="max-width:100%; border-radius:8px; margin:10px 0;"><br>
  <em style="color:#aaa">Figure 4: Vivado Implementation & Constraints</em><br><br>

  <img src="images/fpga_output_image.jpeg" alt="Filtered Output via VGA" style="max-width:100%; border-radius:8px; margin:10px 0;"><br>
  <em style="color:#aaa">Figure 5: Real-time Filtered Output on VGA Display</em><br><br>
'>
  <img src="images/fpga_project2.jpeg" alt="FPGA Real-Time Filtered Output" />
  <p><strong><span class="highlight-line">Real-Time FPGA Image Processing</span></strong></p>
  <p><strong>Click to view full project</strong></p>
</div>

        <div class="project-card" data-type="verilog" data-title="IÂ²C Protocol in Verilog (Master + 5 Slaves)" data-content='
  <strong>ğŸš€ Successfully Designed Bit-Level IÂ²C Protocol using Verilog!</strong><br><br>

  This project simulates a complete <strong>IÂ²C Master-Slave Communication System</strong> with <span class="highlight-line">1 Master</span> and <span class="highlight-line">5 unique Slaves</span>, each identified by its 7-bit address. Designed fully in <strong>Verilog HDL</strong>, this project explores FSM-based protocol logic, data transfer, and ACK/NACK handling.<br><br>

  <strong>ğŸ“Œ Core Features:</strong><br>
  âœ… Master initiates START & STOP conditions<br>
  âœ… Slave address decoding logic<br>
  âœ… FSM for both master & slaves<br>
  âœ… ACK/NACK response system<br>
  âœ… Read and Write data support<br>
  âœ… SDA line handling with tri-state control<br><br>

  <strong>ğŸ§  Tools Used:</strong><br>
  â€¢ Verilog HDL<br>
  â€¢ Icarus Verilog (Simulation)<br>
  â€¢ GTKWave (Waveform Viewer)<br><br>

  <strong>ğŸ”— GitHub:</strong><br>
  <a href="https://github.com/DHANASANKAR2003/VLSI-INTERN-Silicic-Innova-Technology-/tree/main/Verilog%20Project/I2C%20Protocol" target="_blank">
    <i class="fab fa-github"></i> GitHub
  </a><br><br>

  <strong>ğŸ“· Project Snapshots:</strong><br>

  <img src="images/i2c_master_code.jpeg" alt="I2C Master Verilog Code" style="max-width:100%; border-radius:8px; margin:10px 0;">
  <em style="color:#aaa">Figure 1: IÂ²C Master FSM Code (Verilog)</em><br><br>

  <img src="images/i2c_slave1_code.jpeg" alt="Slave 1 Code" style="max-width:100%; border-radius:8px; margin:10px 0;">
  <em style="color:#aaa">Figure 2: Slave 1 Verilog RTL</em><br><br>

  <img src="images/i2c_slave2_code.jpeg" alt="Slave 2 Code" style="max-width:100%; border-radius:8px; margin:10px 0;">
  <em style="color:#aaa">Figure 3: Slave 2 Verilog RTL</em><br><br>

  <img src="images/i2c_slave3_code.jpeg" alt="Slave 3 Code" style="max-width:100%; border-radius:8px; margin:10px 0;">
  <em style="color:#aaa">Figure 4: Slave 3 Verilog RTL</em><br><br>

  <img src="images/i2c_slave4_code.jpeg" alt="Slave 4 Code" style="max-width:100%; border-radius:8px; margin:10px 0;">
  <em style="color:#aaa">Figure 5: Slave 4 Verilog RTL</em><br><br>

  <img src="images/i2c_slave5_code.jpeg" alt="Slave 5 Code" style="max-width:100%; border-radius:8px; margin:10px 0;">
  <em style="color:#aaa">Figure 6: Slave 5 Verilog RTL</em><br><br>

  <img src="images/i2c_waveform.jpeg" alt="I2C Waveform" style="max-width:100%; border-radius:8px; margin:10px 0;">
  <em style="color:#aaa">Figure 7: GTKWave Output â€“ SDA and SCL line transitions</em><br><br>
'>
  <img src="images/i2c_waveform.jpeg" alt="I2C Protocol Thumbnail" />
  <p><strong><span class="highlight-line">IÂ²C Protocol (Master + 5 Slaves)</span></strong></p>
  <p><strong>Click to view full project</strong></p>
</div>


      
      <div class="project-card" data-type="verilog" data-title="Sobel Edge Detection using Verilog + Python Automation" data-content='
  <strong>ğŸ“ Acknowledgements:</strong><br>
  I would like to express my sincere gratitude to <span class="highlight-line">Dr. Swami, Ph.D, iFellow</span> from Silicon Craft VLSI for his exceptional guidance, as well as <span class="highlight-line">Prof. Raja (HoD/ECE, GCE-Erode)</span> and <span class="highlight-line">Dr. Senthilkumar R & Prof. Fairose Banu A</span> for inspiring me throughout this project journey.<br><br>

  <strong>ğŸ” Project Title:</strong><br>
  <span class="highlight-line">High-Performance Sobel Edge Detection using Verilog + Python Automation</span><br><br>

  <strong>ğŸ“Œ Objective:</strong><br>
  To implement a real-time hardware-based edge detection module using the Sobel filter in Verilog, integrating Python for image preprocessing and post-simulation reconstruction. This project demonstrates how image processing can be translated to RTL hardware logic.<br><br>

  <strong>ğŸ› ï¸ Tools Used:</strong><br>
  â€¢ Verilog HDL for RTL design<br>
  â€¢ Icarus Verilog and GTKWave for simulation and debugging<br>
  â€¢ Python (NumPy, PIL, OpenCV) for image processing and automation<br>
  â€¢ Ubuntu Linux environment for build automation<br><br>

  <strong>ğŸ§  Core Concepts:</strong><br>
  â€¢ Line Buffering and 3Ã—3 kernel sliding window<br>
  â€¢ Horizontal and Vertical edge gradient calculation<br>
  â€¢ Signed to unsigned conversion<br>
  â€¢ Thresholding and clamping for visualization<br>
  â€¢ File I/O interfacing between Python and Verilog<br><br>

  <strong>ğŸ“ Project Flow:</strong><br>
  <u>Step 1: Image Preprocessing using Python</u><br>
  â€¢ 256Ã—256 grayscale image loaded and converted to 8-bit pixel values<br>
  â€¢ Pixel values exported into a text file formatted for the Verilog testbench<br><br>

  <u>Step 2: RTL Design in Verilog</u><br>
  â€¢ Designed a 3Ã—3 Sobel filter module with horizontal (Gx) and vertical (Gy) masks:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;Gx = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]<br>
  &nbsp;&nbsp;&nbsp;&nbsp;Gy = [[1, 2, 1], [0, 0, 0], [-1, -2, -1]]<br>
  â€¢ Used three line buffers to implement a sliding 3x3 window<br>
  â€¢ Computed gradient magnitude using: <code>G = |Gx| + |Gy|</code><br>
  â€¢ Output pixels were written to a simulation text file<br><br>

  <u>Step 3: Testbench Simulation</u><br>
  â€¢ Verilog testbench read pixel input file and generated synchronized pixel streams<br>
  â€¢ Collected filtered edge output (sobel_out)<br>
  â€¢ Debugged simulation using GTKWave to verify timing, values, and correctness<br><br>

  <u>Step 4: Image Reconstruction using Python</u><br>
  â€¢ Parsed Verilog output into a new grayscale matrix<br>
  â€¢ Saved output image using Python Pillow/OpenCV libraries<br><br>

  <strong>ğŸ“ˆ Performance & Output:</strong><br>
  â€¢ Accurately detected horizontal, vertical, and diagonal edges<br>
  â€¢ Latency: 3 clock cycles after window fill<br>
  â€¢ Achieved strong contrast between edges and flat regions<br><br>

  <strong>ğŸ“¸ Project Visuals:</strong><br><br>

  <img src="sobel_output.png" alt="Sobel Output Image" style="width:100%; border-radius:10px; margin-bottom:12px;" />
  <em>â–² Final edge-detected image from Verilog output</em><br><br>

  <img src="sobel_design_code.png" alt="RTL Code" style="width:100%; border-radius:10px; margin-bottom:12px;" />
  <em>â–² Sobel filter RTL design module (Verilog)</em><br><br>

  <img src="sobel_testbench.png" alt="Testbench Code" style="width:100%; border-radius:10px; margin-bottom:12px;" />
  <em>â–² Testbench to feed image pixel data</em><br><br>

  <img src="sobel_waveform.png" alt="Waveform Output" style="width:100%; border-radius:10px; margin-bottom:12px;" />
  <em>â–² GTKWave simulation output (sobel_out)</em><br><br>

  <strong>ğŸ† Achievements:</strong><br>
  â€¢ Successfully implemented a scalable edge detection architecture in RTL<br>
  â€¢ Learned real-time image-to-pixel conversion techniques<br>
  â€¢ Developed simulation automation flow using Python and Verilog<br><br>

  <strong>ğŸš€ Future Work:</strong><br>
  â€¢ Deploy design on DE2-70 FPGA with camera interface (OV5640)<br>
  â€¢ Real-time VGA output display for hardware-based image edge detection<br>
  â€¢ Implement additional filters (Gaussian blur, sharpening, erosion)<br><br>

  <strong>ğŸ“š Learning Outcome:</strong><br>
  â€¢ RTL pipelining, convolution kernel implementation<br>
  â€¢ Pythonâ€“Verilog integration via file I/O<br>
  â€¢ Debugging Verilog designs using GTKWave<br>
  â€¢ FPGA implementation planning and performance optimization<br><br>

  <strong>ğŸ’¬ Final Thought:</strong><br>
  This project solidified my passion for image processing in hardware. The satisfaction of reconstructing a full image from pixel outputs proves the power of RTL design.<br><br>

  <strong>ğŸ”— GitHub:</strong>
  <a href="https://github.com/DHANASANKAR2003/VLSI-INTERN-Silicic-Innova-Technology-/tree/main/Verilog%20Project/256_x_256_Image_Processing" 
   target="_blank" 
   style="display:inline-flex; align-items:center; gap:6px; text-decoration:none; color:#00ffe7; font-weight:bold;">
  <i class="fab fa-github" style="font-size: 20px;"></i>
  <span>GitHub</span>
</a>
'>
  <img src="sobel_output1.png" alt="Sobel Edge Detection" />
  <p><strong><span class="highlight-line">Sobel Edge Detection (Verilog + Python)</span></strong></p>
  <p><strong>Click to view full project details</strong></p>
</div>

      <div class="project-card" data-type="verilog" data-title="46-Filter Image Processing Engine (Verilog + Python)" data-content='
  <strong>ğŸš€ Successfully Simulated 46-Filter Image Processing Engine in Verilog!</strong><br><br>

  Iâ€™ve completed the simulation of a high-performance image processing pipeline using <span class="highlight-line">Verilog HDL</span>, featuring 46 individual filters and effects applied on an 8-bit grayscale image. All simulations were performed using <strong>Icarus Verilog</strong> and visualized using Python.<br><br>

  <strong>ğŸ’¡ Features of This Engine:</strong><br>
  ğŸ”¹ Brightness/Contrast Filters (Brighten, Darken, Contrast Boost)<br>
  ğŸ”¹ Bitwise Filters (Mask, XOR, Invert)<br>
  ğŸ”¹ Thresholding & Edge Detection (Sobel, Laplacian, Binarize, Edge Map)<br>
  ğŸ”¹ Morphological Operations (Erosion, Dilation)<br>
  ğŸ”¹ Histogram Equalization, Gaussian Blur, Custom Kernels<br><br>

  <strong>ğŸ§ª Workflow:</strong><br>
  1ï¸âƒ£ <span class="highlight-line">Python Preprocessing</span>: Converted 256Ã—256 grayscale image to memory file for Verilog<br>
  2ï¸âƒ£ <span class="highlight-line">Verilog Testbench</span>: Pixel stream driven through all 46 filters<br>
  3ï¸âƒ£ <span class="highlight-line">Waveform Simulation</span>: Verified output timing using GTKWave<br>
  4ï¸âƒ£ <span class="highlight-line">Python Postprocessing</span>: Converted Verilog output into 46 image previews<br><br>

  <strong>ğŸ“Š Tools Used:</strong><br>
  â€¢ Verilog (Icarus Verilog, GTKWave)<br>
  â€¢ Python (NumPy, Matplotlib, PIL)<br><br>

  <strong>ğŸ”— GitHub:</strong>
  <a href="https://github.com/DHANASANKAR2003/VLSI-INTERN-Silicic-Innova-Technology-/tree/main/Verilog%20Project/256_x_256_Image_Processing" 
   target="_blank" 
   style="display:inline-flex; align-items:center; gap:6px; text-decoration:none; color:#00ffe7; font-weight:bold;">
  <i class="fab fa-github" style="font-size: 20px;"></i>
  <span>GitHub</span>
</a>

  <strong>ğŸ–¼ï¸ Project Snapshots:</strong><br>

  <img src="images/46filters_code.png" alt="Verilog Code" style="max-width:100%; border-radius:8px; margin:10px 0;"><br>
  <em style="color:#aaa">Figure 1: Sample Verilog RTL for Filter Selection</em><br><br>

  <img src="images/46filters_waveform.png" alt="GTKWave Simulation" style="max-width:100%; border-radius:8px; margin:10px 0;"><br>
  <em style="color:#aaa">Figure 2: GTKWave output for selected filter with valid/ready handshake</em><br><br>

  <img src="images/46filters_input.png" alt="Input Image" style="max-width:100%; border-radius:8px; margin:10px 0;"><br>
  <em style="color:#aaa">Figure 3: Original 256Ã—256 grayscale input image</em><br><br>

  <img src="images/46filters_alloutput.png" alt="All Filters Output" style="max-width:100%; border-radius:8px; margin:10px 0;"><br>
  <em style="color:#aaa">Figure 4: Python visualization of all 46 filtered outputs</em><br><br>

  <strong>ğŸ¯ Next Step:</strong> Implement this design on an <span class="highlight-line">Artix-7 FPGA board</span> for real-time camera-based image processing!
'>
  <img src="images/46filters_alloutput.png" alt="46 Filter Output Preview" />
  <p><strong><span class="highlight-line">46-Filter Verilog Image Engine</span></strong></p>
  <p><strong>Click to view full project</strong></p>
</div>


      <div class="project-card" data-type="verilog" data-title="Synchronous FIFO Design in Verilog" data-content='
  <strong>ğŸš€ Successfully Completed a Synchronous FIFO Design in Verilog!</strong><br><br>

  <strong>ğŸ“Œ Highlights of the Design:</strong><br>
  â€¢ Parameterized <span class="highlight-line">depth</span> and <span class="highlight-line">data width</span><br>
  â€¢ Used <code>$clog2</code> for pointer sizing (write/read pointers)<br>
  â€¢ Full and Empty status flag logic<br>
  â€¢ <span class="highlight-line">Self-checking Verilog testbench</span> for simulation<br>
  â€¢ Verified using <span class="highlight-line">Icarus Verilog (iverilog)</span> and GTKWave<br><br>

  <strong>ğŸ§ª Key Testing Scenarios:</strong><br>
  â€¢ Multiple write/read cycles with varying gaps<br>
  â€¢ Full â†’ empty â†’ full cycles<br>
  â€¢ Edge case debugging (e.g., invalid pointer wrap, data overwrite prevention)<br><br>

  <strong>ğŸ’¡ What I Learned:</strong><br>
  â€¢ Sequential logic design (FSM-style FIFO logic)<br>
  â€¢ Circular buffer implementation with careful pointer wrapping<br>
  â€¢ Importance of accurate timing and handshaking in RTL<br>
  â€¢ Debugging waveform-based RTL errors<br><br>

  <strong>ğŸ“Š Tools Used:</strong><br>
  â€¢ Verilog HDL<br>
  â€¢ Icarus Verilog, GTKWave<br><br>

  <strong>ğŸ”— GitHub:</strong>
  <a href="https://github.com/DHANASANKAR2003/VLSI-INTERN-Silicic-Innova-Technology-/tree/main/COMBINATIONAL/DAY%207%20" 
   target="_blank" 
   style="display:inline-flex; align-items:center; gap:6px; text-decoration:none; color:#00ffe7; font-weight:bold;">
  <i class="fab fa-github" style="font-size: 20px;"></i>
  <span>GitHub</span>
</a>

  <strong>ğŸ–¼ï¸ Project Images:</strong><br>

  <img src="images/fifo_code.png" alt="FIFO Verilog Code" style="max-width:100%; border-radius:8px; margin:8px 0;"><br>
  <em style="color: #aaa;">Figure 1: Verilog RTL Code (FIFO Logic)</em><br><br>

  <img src="images/fifo_output.png" alt="FIFO Simulation Output" style="max-width:100%; border-radius:8px; margin:8px 0;"><br>
  <em style="color: #aaa;">Figure 2: FIFO Console Output from Simulation</em><br><br>

  <img src="images/fifo_waveform.png" alt="FIFO GTKWave" style="max-width:100%; border-radius:8px; margin:8px 0;"><br>
  <em style="color: #aaa;">Figure 3: Waveform in GTKWave showing Write/Read Pointers</em><br><br>
'>
  <img src="images/fifo_code1.png" alt="FIFO Design Project Thumbnail" />
  <p><strong><span class="highlight-line">Synchronous FIFO (Verilog)</span></strong></p>
  <p><strong>Click to view full project details</strong></p>
</div>

      <div class="project-card" data-type="verilog" data-title="Smart Traffic Light Controller (Verilog FSM)" data-content='
  <strong>ğŸš¦ Successfully Designed a Smart Traffic Light Controller using Verilog!</strong><br><br>

  Iâ€™ve designed a real-time Traffic Light Controller that simulates a <strong>4-way intersection</strong> using <span class="highlight-line">Verilog FSM (Finite State Machine)</span>. This design supports:<br>
  âœ… Adaptive signal timing based on traffic sensor input<br>
  âœ… Pedestrian crossing control with countdown indicators<br>
  âœ… Emergency vehicle priority override logic<br><br>

  <strong>ğŸ’¡ Core Concepts Implemented:</strong><br>
  â€¢ Mealy & Moore FSM principles<br>
  â€¢ Timer counters for red/yellow/green sequencing<br>
  â€¢ Edge detection for emergency signal & pedestrian button<br>
  â€¢ Output encoding for LEDs and countdown displays<br>
  â€¢ Simulation via Icarus Verilog and waveform debug in GTKWave<br><br>

  <strong>ğŸ› ï¸ Tools & Skills:</strong><br>
  â€¢ Verilog HDL<br>
  â€¢ Icarus Verilog (Simulation)<br>
  â€¢ GTKWave (Debug & Visualization)<br>
  â€¢ FSM Optimization Techniques<br><br>

  <strong>ğŸ“ Mentorship Acknowledgement:</strong><br>
  I sincerely thank <strong>Swami, Ph.D, iFellow</strong> at Silicon Craft VLSI for mentoring me in FSM design and helping refine real-time control logic. Thanks also to <strong>Silicic Innova Technologies Pvt Ltd</strong> for technical support and project-based learning exposure.<br><br>

  <strong>ğŸ“Š System Behavior:</strong><br>
  ğŸš¥ Each signal includes Red, Yellow, Green for North, South, East, West<br>
  ğŸš¨ Emergency vehicle detection instantly prioritizes safe direction<br>
  ğŸš¶ Pedestrian signals operate asynchronously with walk/donâ€™t-walk logic<br>
  â±ï¸ Adaptive timers change based on `traffic_count` inputs (sensor)<br><br>

  <strong>ğŸ”— GitHub:</strong><br>
  <a href="https://github.com/DHANASANKAR2003/VLSI-INTERN-Silicic-Innova-Technology-/blob/main/Verilog%20Project/Traffic_Light_Controller.v" target="_blank">
    <i class="fab fa-github"></i> GitHub
  </a><br><br>

  <strong>ğŸ–¼ï¸ Project Snapshots:</strong><br>

  <img src="images/tfc_code.png" alt="Verilog FSM Code" style="max-width:100%; border-radius:8px; margin:10px 0;"><br>
  <em style="color:#aaa">Figure 1: FSM Code for Smart Traffic Light Sequencing</em><br><br>

  <img src="images/tfc_output.png" alt="Output LED State" style="max-width:100%; border-radius:8px; margin:10px 0;"><br>
  <em style="color:#aaa">Figure 2: Simulated Output Timing for Directional Lights</em><br><br>

  <img src="images/tfc_waveform.png" alt="GTKWave FSM Debug" style="max-width:100%; border-radius:8px; margin:10px 0;"><br>
  <em style="color:#aaa">Figure 3: GTKWave showing FSM state transitions and pedestrian timing</em><br><br>

  <strong>ğŸš€ Future Improvements:</strong><br>
  â€¢ Add night mode with blinking yellow pattern<br>
  â€¢ FPGA implementation for real intersection signal box<br>
  â€¢ Integrate with camera or IR sensors for smarter vehicle detection<br>
'>
  <img src="images/tfc_output1.png" alt="Traffic Light Simulation" />
  <p><strong><span class="highlight-line">Smart Traffic Light FSM</span></strong></p>
  <p><strong>Click to view full project</strong></p>
</div>


      <div class="project-card" data-type="verilog" data-title="Sequential Circuits Design using Verilog HDL" data-content='
  <strong>ğŸ‰ Project Milestone Achieved! ğŸ‰</strong><br><br>

  Iâ€™m excited to share that I have successfully designed and simulated major <strong>Sequential Circuits</strong> using <span class="highlight-line">Verilog HDL</span>!<br><br>

  âœ… D Flip-Flopâ€ƒâ€ƒâœ… T Flip-Flopâ€ƒâ€ƒâœ… JK Flip-Flopâ€ƒâ€ƒâœ… SR Flip-Flop<br>
  âœ… Up/Down Countersâ€ƒâ€ƒâœ… Ring Counterâ€ƒâ€ƒâœ… SISO, SIPO, PISO, PIPO Registers<br>
  âœ… Bidirectional & Universal Shift Registers<br><br>

  <strong>ğŸ”¬ Key Learnings:</strong><br>
  â€¢ Clocked sequential behavior in HDL<br>
  â€¢ Register transfer and control logic<br>
  â€¢ Edge-sensitive triggering & asynchronous resets<br>
  â€¢ Synthesis-friendly RTL coding<br><br>

  <strong>ğŸ§  Tools Used:</strong><br>
  â€¢ Verilog HDL<br>
  â€¢ Icarus Verilog<br>
  â€¢ GTKWave<br><br>

  <strong>ğŸ“ˆ Project Verification:</strong><br>
  I analyzed both digital and analog waveform views to confirm data storage, propagation, and timing correctness.<br><br>

  <strong>ğŸ“ Mentorship:</strong><br>
  Thank you <strong>Swami, Ph.D, iFellow</strong> (Silicon Craft VLSI) and <strong>Silicic Innova Technologies</strong> for their invaluable support and mentorship throughout this project.<br><br>

  <strong>ğŸ”— GitHub:</strong><br>
  <a href="https://github.com/DHANASANKAR2003" target="_blank">
    <i class="fab fa-github"></i> GitHub
  </a><br><br>

  <strong>ğŸ–¼ï¸ Project Snapshots:</strong><br>

  <img src="images/seq_code1.jpeg" alt="Verilog Code - Flip-Flops" style="max-width:100%; border-radius:8px; margin:10px 0;"><br>
  <em style="color:#aaa">Figure 1: Verilog Code </em><br><br>

  <img src="images/seq_code2.jpeg" alt="Verilog Code - Counters" style="max-width:100%; border-radius:8px; margin:10px 0;"><br>
  <em style="color:#aaa">Figure 2: Verilog Code </em><br><br>

  <img src="images/seq_output1.jpeg" alt="Output - Shift Register Simulation" style="max-width:100%; border-radius:8px; margin:10px 0;"><br>
  <em style="color:#aaa">Figure 3: Output1 </em><br><br>

  <img src="images/seq_output2.jpeg" alt="Counter Output" style="max-width:100%; border-radius:8px; margin:10px 0;"><br>
  <em style="color:#aaa">Figure 4: Output2 </em><br><br>

  <img src="images/seq_waveform.jpeg" alt="GTKWave waveform" style="max-width:100%; border-radius:8px; margin:10px 0;"><br>
  <em style="color:#aaa">Figure 5: GTKWave showing state transitions of flip-flops</em><br><br>
'>
  <img src="images/seq_output1.jpeg" alt="Sequential Circuits Simulation" />
  <p><strong><span class="highlight-line">Sequential Circuits in Verilog</span></strong></p>
  <p><strong>Click to view full project</strong></p>
</div>
      <!-- Add more cards here as needed -->
    </div>
      </div>
  </main>

  <!-- Modal -->
  <div id="projectModal">
    <span class="close">&times;</span>
    <div class="modal-box">
      <h2 id="modalTitle"></h2>
      <div id="modalContent"></div>
    </div>
  </div>

   <!-- JS -->
  <script>
document.addEventListener("DOMContentLoaded", () => {
  const modal = document.getElementById("projectModal");
  const modalTitle = document.getElementById("modalTitle");
  const modalContent = document.getElementById("modalContent");
  const closeBtn = document.querySelector(".close");

  document.querySelectorAll('.project-card').forEach(card => {
    card.addEventListener('click', () => {
      modalTitle.innerHTML = card.getAttribute('data-title');
      modalContent.innerHTML = card.getAttribute('data-content');
      modal.style.display = "flex";
      document.querySelector(".modal-box").scrollTop = 0;
      document.body.classList.add("modal-open");
    });
  });

  closeBtn.addEventListener("click", () => {
    modal.style.display = "none";
    document.body.classList.remove("modal-open");
  });
});
</script>

  <script src="script.js"></script>
</body>
</html>
